#!/usr/bin/env python3
# NOTE: kept up to date with `black "${file}" && isort --profile black --lai 2 "${file}"`

# --- Imports ---
from datetime import datetime
from os import getenv
from pathlib import Path
from sys import exit, platform
from typing import NoReturn


# --- Constants ---
# Colors
RED = "\x1b[31;1m"
GREEN = "\x1b[32;1m"
YELLOW = "\x1b[33;1m"
BLUE = "\x1b[34;1m"
MAGENTA = "\x1b[35;1m"
CYAN = "\x1b[36;1m"
RESET = "\x1b[00m"

# Pacman
PACMAN_CONFIG = Path("/etc/pacman.conf")
PACMAN_DEFAULT_LOGFILE = Path("/var/log/pacman.log")
ISO_FMT = "%Y-%m-%dT%H:%M:%S%z"
CUSTOM_FMT = "%Y-%m-%d %H:%M:%S"

# Updates
RECOMMENDED_UPDATE_DAYS = 7
UPDATE_ACCEPTABLE = GREEN
UPDATE_CAUTIOUS = YELLOW
UPDATE_DANGEROUS = RED

# Debug
ENABLE_DEBUG = True if getenv("DEBUG") == "1" else False


# --- Functions ---
def error(message: str) -> NoReturn:
    print(f"{RED}[ERROR]{RESET} {message}")
    exit(1)


def debug(message: str) -> None:
    if ENABLE_DEBUG:
        print(f"{CYAN}[DEBUG]{RESET} {message}")


def get_log_file() -> Path:
    # Read pacman configuration
    custom_path: Path = PACMAN_DEFAULT_LOGFILE
    with open(PACMAN_CONFIG, "r") as config:
        # Get all entries for the configuration - for redundancy
        log_entries = [
            line.strip() for line in config.readlines() if line.startswith("LogFile")
        ]

        # Get the last entry, isolating the path and clean it
        log_path = log_entries[-1].split("=")[-1].strip(" ")

        # Check if the default is the same
        if not PACMAN_DEFAULT_LOGFILE.match(log_path):
            custom_path = Path(log_path)

    # Return result
    return custom_path


def get_last_action_date(log_file: Path) -> datetime:
    # Parse the log file
    with open(log_file, "r") as file:
        # synchronizing package lists
        # last_action = file.readlines()[-1].strip().split(' ')[0].strip("[]")
        last_action = (
            [
                line.strip()
                for line in file.readlines()
                if r"synchronizing package lists" in line
            ][-1]
            .strip()
            .split(" ")[0]
            .strip("[]")
        )

        # Parse datetime
        return datetime.strptime(last_action, ISO_FMT)


def show_recency(current_time: datetime, action_date: datetime):
    # Check difference in days
    days_since_update = abs((current_time.date() - action_date.date()).days)

    # Day range acceptability status
    status = ""
    if days_since_update >= RECOMMENDED_UPDATE_DAYS * 2:
        status = UPDATE_DANGEROUS
    elif days_since_update >= RECOMMENDED_UPDATE_DAYS:
        status = UPDATE_CAUTIOUS
    elif days_since_update >= 0:
        status = UPDATE_ACCEPTABLE
    else:
        error("Invalid times!")

    # Print Recency
    print(
        f"{action_date.strftime(CUSTOM_FMT)}",
        f"({status}{days_since_update} {'day' if days_since_update == 1 else 'days'} since update{RESET})",
    )


# --- Executable ---
if __name__ == "__main__":
    # Platform safety check
    if not platform.lower().startswith("lin"):
        exit("Invalid platform! Must run on Linux!")

    # Get pacman's log file
    file = get_log_file()

    # Get relevant dates
    action = get_last_action_date(file)
    now = datetime.now(tz=action.tzinfo)
    debug(f"Current Time:\t{MAGENTA}{now.strftime(CUSTOM_FMT)}{RESET}")
    debug(f"Last Action:\t{MAGENTA}{action.strftime(CUSTOM_FMT)}{RESET}")

    # Show recency
    show_recency(now, action)
